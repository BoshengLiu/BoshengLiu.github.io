# 排序
# 排序算法简介
## 1. 如何分析一个“排序算法”<br>
学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。

## 2. 排序算法的执行效率<br>
对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：

1. **最好情况、最坏情况、平均情况时间复杂度**
    * 我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。为什么要区分这三种时间复杂度呢？ 
        * 第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。
        * 第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。

2. **时间复杂度的系数、常数 、低阶**
    * 我们知道，时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

3. **比较次数和交换（或移动）次数**
    * 基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

## 3. 排序算法的内存消耗
&#8195; 算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

## 4. 排序算法的稳定性
&#8195; 仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，**稳定性**。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

&#8195; 这里通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作**稳定的排序算法**；如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**。

---

# 一、冒泡排序
## 1. 介绍
&#8195; 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。冒泡排序流程参考下图：

![](https://upload-images.jianshu.io/upload_images/16911112-ccf18a0d641b5c3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 问题
1. **第一，冒泡排序是原地排序算法吗**？<br>

&#8195; 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

2. **第二，冒泡排序是稳定的排序算法吗**？<br>

&#8195; 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

3. **第三，冒泡排序的时间复杂度是多少**？<br>

&#8195; 最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 $O(n^2)$。

## 3. 参考程序

```python
def bubble_sort(list):
    n = len(list)
    count = 0
    for j in range(n-1):
        for i in range(n-1-j):
            if list[i] > list[i+1]:
                list[i],list[i+1] = list[i+1],list[i]
                count += 1
        if count == 0:
            return

```

---

# 二、插入排序
## 1. 介绍
&#8195; 对于一个数组，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。插入阿皮序流程图如下：

![](https://upload-images.jianshu.io/upload_images/16911112-0ec9d4f786f4f21e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 问题
1. **第一，插入排序是原地排序算法吗**？<br>

&#8195; 从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。

2. **第二，插入排序是稳定的排序算法吗**？<br>

&#8195; 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

3. **第三，插入排序的时间复杂度是多少**？<br>

&#8195; 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是**从尾到头遍历已经有序的数据**。<br>
&#8195; 如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 $O(n^2)$。

## 3. 插入排序和冒泡排序的对比
&#8195; 冒泡排序和插入排序的时间复杂度都是 $O(n^2)$，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

&#8195; 我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。


## 4. 参考程序

```python
def insert_sort(list):
    n = len(list)
    for j in range(1,n):
        i = j
        while i > 0:
            if list[i] < list[i-1]:
                list[i],list[i-1] = list[i-1],list[i]
                i -= 1
            else:
                break

```

---

# 三、选择排序
## 1. 介绍
&#8195; 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![](https://upload-images.jianshu.io/upload_images/16911112-ad68ecd2fcdfe644.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 问题
1. **第一，选择排序是原地排序算法吗**？<br>

&#8195; 首先，选择排序空间复杂度为 O(1)，是一种原地排序算法。

2. **第二，选择排序是稳定的排序算法吗**？<br>

&#8195; 选择排序是一种不稳定的排序算法。从前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

3. **第三，选择排序的时间复杂度是多少**？<br>

&#8195; 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 $O(n^2)$。

## 3. 参考程序

```python
def select_sort(list):
    n = len(list)
    for j in range(0,n-1):
        min_index = j
        for i in range(j+1,n):
            if list[min_index] > list[i]:
                min_index = i
        list[j],list[min_index] = list[min_index],list[j]

```

&#8195; 这里我们可以总结一下3种排序，如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-9239c2081920a5a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

---

# 四、希尔排序
## 1. 介绍
&#8195; 希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。详细流程如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-f7f9d1b2081a0a2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 2. 参考程序

```python
def shell_sort(list):
    n = len(list)
    gap = n // 2
    while gap > 0:
        for j in range(gap,n):
            i = j
            while i > 0:
                if list[i] < list[i-gap]:
                    list[i],list[i-gap] = list[i-gap],list[i]
                    i -= gap
                else:
                    break

```

---

# 五、归并排序
## 1. 介绍
&#8195; 归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

&#8195; 归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。原理如下图：

![](https://upload-images.jianshu.io/upload_images/16911112-83ff566cdf5034b2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 问题
**第一，归并排序是稳定的排序算法吗？**<br>
&#8195; 归并排序是一个稳定的排序算法。

**第二，归并排序的时间复杂度是多少？**<br>
&#8195; 归并排序的时间复杂度是 O(nlogn)。

**第三，归并排序的空间复杂度是多少？**<br>
&#8195; 归并排序的时间复杂度任何情况下都是 O(nlogn)，但是它有一个致命的“弱点”，那就是归并排序不是原地排序算法。


## 3. 参考程序
* 我们先看一下流程图，如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-2ddc0261a2cdb595.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 参考程序

```python
def merge_sort(list):
    n = len(list)
    if n <= 1:
        return
    mid = n // 2  # 拆分序列
    # left采取归并排序后形成的有序的新的列表
    left_list = merge_sort(list[:mid])
    # right采取归并排序后形成的有序的新的列表
    rigth_list = merge_sort(list[mid:])

    # 将两个子序列合并成一个新的整体
    """
    具体过程：
    1. 给定两个子序列两个游标，对应子序列最左端，分别为 left 和 right
    2. 比较 left 和 right 对应的值，将小的放入 result，同时将游标往后移动
    3. 重复步骤 2 ，直到两个子序列合并完成
    4. 重复 1-3 ，直到所有的数字完成排序
    """
    left_point, right_point = 0, 0
    result = [] 
    while left_point < len(left_list) and right_point < len(rigth_list):
        if left_list[left_point] < rigth_list[right_point]:
            result.append(left_list[left_point])
            left_point += 1
        else:
            result.append(rigth_list[right_point])
            right_point += 1

    result += left_list[left_point]
    result += rigth_list[right_point]
    return result

```

---

# 六、快速排序

## 1. 介绍
&#8195; 快排是一种原地、不稳定的排序算法。快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-efade7ca1c7807b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 快速排序和归并排序的对比
&#8195; 它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。

### 1. 过程对比
&#8195; 归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

### 2. 时间复杂度
&#8195; 归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。

&#8195; 快速排序算法虽然最坏情况下的时间复杂度是 $O(n^2)$，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 $O(n^2)$ 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。

## 3. 参考程序
* 我们先看一下流程图，如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-612a607cc2eb48b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 3.1 分治递归

```python
def quickSort(list):
    # 基线条件：为空或只包含一个元素的数组是“有序”的
    if len(list) < 2:
        return list
    else:
        pivot = list[0]
        # 由所有小于基准值的元素组成的子数组
        low = [i for i in list[1:] if i <= pivot]
        # 由所有大于基准值的元素组成的子数组
        high = [i for i in list[1:] if i > pivot]

        return quickSort(low) + [pivot] + quickSort(high)

```

### 3.2 原地交换
* 从前面分治递归的角度看，需要额外的空间去保存分开后的数组，这里我们可以考虑使用交换的方法完成快排，而不需要额外的空间开销。参考程序：

```python
def quick_sort(lists, low, high):   # low = 0, high = len(lists) - 1
    """原地快排"""
    if low < high:
        # 取第一个元素为基准元素 pivot，j 表示小于 pivot 的下标，初始化 j 为0
        pivot, j = lists[low], low
        # 遍历数组，当数组的值小于 pivot 时，j 向右移动一位，j、i 位置交换元素
        # 当数组的值大于对比值时，j 位置不变，i 继续遍历
        # 遍历完的结果为：pivot [小于 pivot 的元素] [大于 pivot 的元素]
        # 此时 j 指向 [小于 pivot 的元素] 最后一个位置
        # 最后将 pivot 和 j 指向的元素交换位置
        for i in range(low + 1, high + 1):
            if lists[i] <= pivot:
                j += 1
                lists[j],lists[i] = lists[i],lists[j]
                print(lists)
        lists[low],lists[j] = lists[j],lists[low]
        
        # 递归
        quick_sort(lists,low,j-1)
        quick_sort(lists,j+1,high)

    return lists

```

---

# 七、桶排序
## 1. 介绍
&#8195; 桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了，桶排序的时间复杂度是 O(n)。流程图如下所示：

![](https://upload-images.jianshu.io/upload_images/16911112-f040dd974115de7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 要求
**1. 首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序**。<br>

这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。

**2. 其次，数据在各个桶之间的分布是比较均匀的**。<br>

如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。

**3. 桶排序比较适合用在外部排序中**。<br>

所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

## 3. 参考程序

```python
def bucket_sort(lists):
    """桶排序"""
    buckets = [0] * ((max(lists) - min(lists)) + 1)  # 初始化桶，每个桶的元素为0
    for i in range(len(lists)):
        buckets[lists[i] - min(lists)] += 1  # 遍历数组a，在桶的相应位置累加值
    b = []
    for i in range(len(buckets)):
        if buckets[i] != 0:
            b += [i + min(lists)] * buckets[i]
    return b
    
```

---

# 八、计数排序
## 1. 简介
&#8195; 计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。

## 2. 例子
&#8195; 举个例子，假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考生，而是对应的考生个数。我们只需要遍历一遍考生分数，就可以得到 C[6]的值。从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-027e3e77850ee6ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 那我们如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？思路是这样的：我们对 C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数 k 的考生个数。如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-432711c45304875c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 我们**从后到前依次扫描数组 A**。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。以此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。流程图如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-8f75f8eb7cfaa4f1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 3. 总结
&#8195; **计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。**

## 4. 参考代码

```python
def counting_sort(lists, k):  # k = max(lists)
    """计数排序"""
    n = len(lists)  # 计算a序列的长度
    output = [0 for i in range(n)]  # 设置输出序列并初始化为0
    counts = [0 for i in range(k + 1)]  # 设置计数序列并初始化为0

    # 遍历数组，每当取出一个值时，计数序列所对应位置的值 +1，直到数组遍历完毕
    # 比如 [0, 2, 0, 1, 1, 0, 0, 0, 0, 0, 0]，表示数组 1 有 2 个，3 有 1 个，4 有 1 个
    for j in lists:
        counts[j] = counts[j] + 1

    # 从左到右统计计数序列，使得当前的数值为小于或等于计数序列对应的数字的个数
    # 比如 count[5] = 8，表示 小于等于 5 的数有 8 个
    for i in range(1, len(counts)):
        counts[i] = counts[i] + counts[i - 1]

    # 输出排序结果
    for j in lists:
        output[counts[j] - 1] = j   # 输出序列添加对应的数字
        counts[j] = counts[j] - 1   # 计数序列将已添加的数字对应的计数值 -1
    return output

```

---

# 九、基数排序
## 1. 简介
&#8195; 基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

&#8195; 它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

&#8195; 基数排序的方式可以采用 **LSD**（**Least significant digital**）或 **MSD**（**Most significant digital**），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。

&#8195; 基数排序的时间复杂度是 ${\displaystyle O(k\cdot n)}$，其中 ${\displaystyle n}$ 是排序元素个数，${\displaystyle k}$ 是数字位数。注意这不是说这个时间复杂度一定优于 ${\displaystyle O\left(n\cdot \log \left(n\right)\right)}$，${\displaystyle k}$ 的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；${\displaystyle k}$ 决定了进行多少轮处理，而 ${\displaystyle n}$ 是每轮处理的操作数目。

## 2. 例子
&#8195; 假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？

&#8195; 思路是这样的：先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。由于手机号码太长，这里用字符串的例子来演示，如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-23057a97e2f43530.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 注意，这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。

## 3. 拓展与总结
### 拓展
&#8195; 实际上，有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词，最短的只有 1 个字母，最长的有 45 个字母，中文翻译是尘肺病。对于这种不等长的数据，基数排序还适用吗？实际上，我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据 ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。

### 总结
&#8195; **基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。**

## 4. 参考程序

```python
import math

def base_sort(lists, radix=2):
    """基数排序，lists为整数列表， radix为基数"""
    K = int(math.ceil(math.log(max(lists) + 1, radix)))  # 用K位数可表示任意整数
    for i in range(1, K + 1):  # K次循环
        bucket = [[] for j in range(radix)]  # 不能用 [[]]*radix，否则相当于开了radix个完全相同的list对象
        for val in lists:
            bucket[val % (radix ** i) // (radix ** (i - 1))].append(val)  # 獲得整數第K位數字 （從低到高）
        del lists[:]
        for each in bucket:
            lists.extend(each)  # 桶合并
    return lists

```

---

# 十、如何选择合适的排序算法
&#8195; 我们先来回归前面学过的排序算法，整理如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-6bf2be46d3fc80d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 1. 算法的选择
&#8195; 如果对小规模数据进行排序，可以选择时间复杂度是 $O(n^2)$ 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。

## 2. 如何优化快速排序？
&#8195; 我们先来看下，为什么最坏情况下快速排序的时间复杂度是 $O(n^2)$ 呢？如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 $O(n^2)$。实际上，**这种 $O(n^2)$ 时间复杂度出现的主要原因还是因为我们分区点选得不够合理**。

&#8195; 最理想的分区点是：**被分区点分开的两个分区中，数据的数量差不多**。

&#8195; 如果很粗暴地直接选择第一个或者最后一个数据作为分区点，不考虑数据的特点，肯定会出现之前讲的那样，在某些情况下，排序的最坏情况时间复杂度是 $O(n^2)$。为了提高排序算法的性能，我们也要尽可能地让每次分区都比较平均。这里介绍两个比较常用、比较简单的分区算法

**1. 三数取中法**<br>

&#8195; 我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。

**2. 随机法**<br>

&#8195; 随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。