# 实际问题
## 问题1
* 现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？

* 解题思路
    * 先构建十条 I/O 流，分别指向十个文件，每条 I/O 流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的 I/O 流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，I/O 流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较 n 次，每次比较选出一条数据来写入，时间复杂度是 O（n），空间复杂度是 O（1），几乎不占用内存。

## 问题2
* 如何用快排思想在O(n)内查找第K大元素？

* 解题思路
    * 快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开篇的问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。
    
    * 我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。
    
    * 如果 p+1=K，那 A[p]就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K<p+1，那我们就在 A[0…p-1]区间查找。

![](https://upload-images.jianshu.io/upload_images/16911112-47772611f7b5473b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 问题3
* 如何根据年龄给100万用户数据排序？

* 解题思路
    * 我们假设年龄的范围最小 1 岁，最大不超过 120 岁。我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。

## 问题4
* 假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？

* 解题思路

## 问题5
* 如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。

* 解题思路

```python

```

## 问题6
* 如何快速定位IP对应的省份地址？

* 解题思路
    * 如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。
    
    * 我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。然后，这个问题就可以转化为“在有序数组中，查找最后一个小于等于某个给定值的元素”了。
    
    * 当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。

## 问题7
* 如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？

* 解题思路

## 问题8
* 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？

* 解答：
Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。Redis 中的有序集合支持的核心操作主要有下面这几个：

    * 插入一个数据；
    
    * 删除一个数据；
    
    * 查找一个数据；
    
    * 按照区间查找数据（比如查找值在[100, 356]之间的数据）；
    
    * 迭代输出有序序列。<br>
    
&#8195; 其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。
    
&#8195; 但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。
    
&#8195; 当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。
    
&#8195; 不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。

## 问题9
* Word 文档中单词拼写检查功能是如何实现的？

* 思路：
    * 常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。

    * 当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。
     

## 问题10
* 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

* 思路：
    * 遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。

    * 如果 K 不是很大（数据分布比较均匀），可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。

## 问题11    
* 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？   

* 思路：
    * 以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于 0，说明存在相同字符串。时间复杂度 O(N)。

## 问题12
* 假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：

    * 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；
    
    * 查找积分在某个区间的猎头 ID 列表；
    
    * 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。

* 思路：以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。

    * ID 在散列表中所以可以 O(1) 查找到这个猎头；
    
    * 积分以跳表存储，跳表支持区间查询；
    
    * 这点根据目前学习的知识暂时无法实现，老师文中也提到了。
    







