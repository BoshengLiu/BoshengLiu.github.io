# 实际问题
## 问题1
* 现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？

* 解题思路
    * 先构建十条 I/O 流，分别指向十个文件，每条 I/O 流读取对应文件的第一条数据，然后比较时间戳，选择出时间戳最小的那条数据，将其写入一个新的文件，然后指向该时间戳的 I/O 流读取下一行数据，然后继续刚才的操作，比较选出最小的时间戳数据，写入新文件，I/O 流读取下一行数据，以此类推，完成文件的合并， 这种处理方式，日志文件有n个数据就要比较 n 次，每次比较选出一条数据来写入，时间复杂度是 O（n），空间复杂度是 O（1），几乎不占用内存。

## 问题2
* 如何用快排思想在O(n)内查找第K大元素？

* 解题思路
    * 快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开篇的问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。
    
    * 我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。
    
    * 如果 p+1=K，那 A[p]就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K<p+1，那我们就在 A[0…p-1]区间查找。

![](https://upload-images.jianshu.io/upload_images/16911112-47772611f7b5473b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 问题3
* 如何根据年龄给100万用户数据排序？

* 解题思路
    * 我们假设年龄的范围最小 1 岁，最大不超过 120 岁。我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。

## 问题4
* 假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？

* 解题思路

## 问题5
* 如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。

* 解题思路

```python

```

## 问题6
* 如何快速定位IP对应的省份地址？

* 解题思路
    * 如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。
    
    * 我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。然后，这个问题就可以转化为“在有序数组中，查找最后一个小于等于某个给定值的元素”了。
    
    * 当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。

## 问题7
* 如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？

* 解题思路

## 问题8
* 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？

* 解答：
Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。Redis 中的有序集合支持的核心操作主要有下面这几个：

    * 插入一个数据；
    
    * 删除一个数据；
    
    * 查找一个数据；
    
    * 按照区间查找数据（比如查找值在[100, 356]之间的数据）；
    
    * 迭代输出有序序列。<br>
    
&#8195; 其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。
    
&#8195; 但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。
    
&#8195; 当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。
    
&#8195; 不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。

