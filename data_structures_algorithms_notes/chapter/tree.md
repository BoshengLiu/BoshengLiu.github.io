# 树
# 一、简介
## 1. 定义
&#8195; 树状图是一种数据结构，它是由n（n>=0）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
1. 每个结点有零个或多个子结点。

2. 没有父结点的结点称为根结点。

3. 每一个非根结点有且只有一个父结点。

4. 除了根结点外，每个子结点可以分为多个不相交的子树。

![](https://upload-images.jianshu.io/upload_images/16911112-902e96b17b9e4270.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 节点

&#8195; 比如下面这幅图，A 节点就是 B 节点的**父节点**，B 节点是 A 节点的**子节点**。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为**兄弟节点**。我们把没有父节点的节点叫做**根节点**，也就是图中的节点 E。我们把没有子节点的节点叫做**叶子节点**或者**叶节点**，比如图中的 G、H、I、J、K、L 都是叶子节点。

![](https://upload-images.jianshu.io/upload_images/16911112-36b69d6b0bb5595e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 3. 深度
除此之外，关于“树”，还有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的：定义一棵树的根结点层次为1，其他结点的层次是其父结点层次加1。一棵树中所有结点的层次的最大值称为这棵树的深度。

![](https://upload-images.jianshu.io/upload_images/16911112-0bd386cc6dd41bad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 4. 种类
* 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树。
* 有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树。
* 二叉树：每个节点最多含有两个子树的树称为二叉树。
* 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树。
* 完全二叉树：有$2^k-1$个节点的满二叉树称为完全二叉树。
* 哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。

## 5. 遍历方法
* 1. 先序遍历
* 2. 中序遍历
* 3. 后序遍历

---

# 二、二叉树
## 1. 介绍
&#8195; 树结构多种多样，不过我们最常用还是二叉树。二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点，如下图所示。

![二叉树1.jpg](https://upload-images.jianshu.io/upload_images/16911112-3ff5bd81a5fbaf6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 其中，编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做**满二叉树**。

&#8195; 编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做**完全二叉树**。

![](https://upload-images.jianshu.io/upload_images/16911112-6f56e6663a262498.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 树的存储方式
&#8195; 想要存储一棵二叉树，我们有两种方法，一种是**基于指针**或者引用的**二叉链式存储法**，一种是**基于数组的顺序存储法**。

### 2.1 链式存储法
&#8195; 我们先来看比较简单、直观的**链式存储法**。从图中可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。

![](https://upload-images.jianshu.io/upload_images/16911112-7275f0d3bc6f2dc4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2.2 顺序存储法
&#8195; 我们再来看，基于数组的**顺序存储法**。我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。

![](https://upload-images.jianshu.io/upload_images/16911112-840424640eb631da.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 总结一下，如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。

&#8195; 如果是非完全二叉树，其实会浪费比较多的数组存储空间，如下图所示。

![](https://upload-images.jianshu.io/upload_images/16911112-0daafdfe17ba8529.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。

## 3. 二叉树的遍历
&#8195; 如何将所有节点都遍历打印出来呢？经典的方法有三种，**前序遍历、中序遍历**和**后序遍历**。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。

* **前序遍历**是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

* **中序遍历**是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

* **后序遍历**是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

![](https://upload-images.jianshu.io/upload_images/16911112-2eada52395bcbecb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; **实际上，二叉树的前、中、后序遍历就是一个递归的过程**。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。

&#8195; 从前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。

* 参考程序

```python
class Node(object):  # 创建节点，每个节点有两个子节点
    def __init__(self, item):
        self.item = item
        self.left = None
        self.right = None


class Tree(object):  # 创建树
    def __init__(self):
        self.root = None

    def add(self, item):  # 添加元素
        node = Node(item)
        if self.root is None:
            self.root = node
            return
        queue = [self.root]
        while queue:  # 只要队列不为空
            cur_node = queue.pop(0)  # 读取当前节点
            if cur_node.left is None:  # 判断当前节点的左子节点是否为空
                cur_node.left = node
                return
            else:
                queue.append(cur_node.left)
            if cur_node.right is None:  # 判断当前节点的右子节点是否为空
                cur_node.right = node
                return
            else:
                queue.append(cur_node.right)

    def breath_travel(self):  # 广度优先遍历
        if self.root is None:
            return
        queue = [self.root]
        while queue:  # 当队列存在时
            cur_node = queue.pop(0)
            print(cur_node.item, end=' ')
            if cur_node.left is not None:
                queue.append(cur_node.left)  # 添加左子元素
            if cur_node.right is not None:
                queue.append(cur_node.right)  # 添加右子元素

    def pre_order(self, node):  # 先序遍历
        if node == None:
            return
        print(node.item, end=' ')
        self.pre_order(node.left)
        self.pre_order(node.right)

    def in_order(self, node):  # 中序遍历
        if node == None:
            return
        self.in_order(node.left)
        print(node.item, end=' ')
        self.in_order(node.right)

    def post_order(self, node):  # 后序遍历
        if node == None:
            return
        self.post_order(node.left)
        self.post_order(node.right)
        print(node.item, end=' ')

```

---

# 三、二叉查找树
&#8195; 二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。

&#8195; 这些都依赖于二叉查找树的特殊结构。**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值**，如下图所示。

![](https://upload-images.jianshu.io/upload_images/16911112-224de0e47c40fe3b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 1. 查找数据
&#8195; 首先，我们看如何在二叉查找树中查找一个节点。我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

![](https://upload-images.jianshu.io/upload_images/16911112-b9b1a1cd80e30bc6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 参考程序如下：
```python

```

## 2. 插入数据
&#8195; 二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。

&#8195; 如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

![](https://upload-images.jianshu.io/upload_images/16911112-84117da9050e34fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 参考程序如下：
```python

```

## 3. 删除操作
&#8195; 二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作就比较复杂了 。针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。

* 第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。

* 第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。

* 第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。

![](https://upload-images.jianshu.io/upload_images/16911112-80e137ae63be0de3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 4. 其他操作
&#8195; 除了插入、删除、查找操作之外，二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。

&#8195; 二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。

* 支持重复数据的二叉查找树

很多时候，在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。

那如果存储的两个对象键值相同，这种情况该怎么处理呢？
* 第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。

* 第二种方法比较不好理解，不过更加优雅。每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。

![](https://upload-images.jianshu.io/upload_images/16911112-406d5bb382321ea2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。

![](https://upload-images.jianshu.io/upload_images/16911112-3899c43df171c86b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。

![](https://upload-images.jianshu.io/upload_images/16911112-451fbbd0948866b2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 5. 时间复杂度分析
&#8195; 实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。

![](https://upload-images.jianshu.io/upload_images/16911112-852e0d2316136d90.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？

&#8195; 树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 $2^{(K-1)}$。

&#8195; 不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 $2^{(L-1)}$ 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：


$n >= 1+2+4+8+...+2^{(L-2)}+1$

$n <= 1+2+4+8+...+2^{(L-2)} + 2^{(L-1)}$

&#8195; 借助等比数列的求和公式，我们可以计算出，L 的范围是[log2(n+1), log2n +1]。完全二叉树的层数小于等于 log2n +1，也就是说，完全二叉树的高度小于等于 log2n。

&#8195; 显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是我们下一节课要详细讲的，一种特殊的二叉查找树，平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。

## 6. 选择二叉查找树的原因
&#8195; 在前面我们学过散列表，散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？我认为有下面几个原因：

* 第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。

* 第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。

* 第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。

* 第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。

* 最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。

综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。

---

# 四、平衡二叉查找树（红黑树）
&#8195; 平衡二叉树的严格定义是这样的：**二叉树中任意一个节点的左右子树的高度相差不能大于 1**。从这个定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。

![](https://upload-images.jianshu.io/upload_images/16911112-72d0e57e6e56dc40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。

&#8195; 所以，**平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些**。

&#8195; 所以，如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比 log2n 大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。

## 1. 红黑树
&#8195; 红黑树的英文是“Red-Black Tree”，简称 R-B Tree，它是一种不严格的平衡二叉查找树。顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：

* 根节点是黑色的；

* 每个叶子节点都是黑色的空节点（NIL），也就是说，**叶子节点不存储数据**；

* 任何相邻的节点都不能同时为红色，也就是说，**红色节点是被黑色节点隔开的**；

* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。

如下图所示，这里将黑色的、空的叶子节点都省略掉了。

![](https://upload-images.jianshu.io/upload_images/16911112-119a6a4f956b951f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 2. 推导过程
&#8195; 平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“**平衡”的意思可以等价为性能不退化，“近似平衡”就等价为性能不会退化得太严重**。

&#8195; 前面讲过，二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log2n，所以如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近 log2n 就好了。

推导过程：

* 首先，我们来看，如果我们将红色节点从红黑树中去掉，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。

![](https://upload-images.jianshu.io/upload_images/16911112-5b9778ca5e6dddeb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。



---

# 五、递归树

















