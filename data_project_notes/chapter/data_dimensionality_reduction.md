# 数据降维
# 一、线性判别LDA
## 1. LDA的思想

&#8195;  LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。

&#8195;  可能还是有点抽象，我们先看看最简单的情况。假设我们有两类数据 分别为红色和蓝色，如下图所示，这些数据特征是二维的，我们希望将这些数据投影到一维的一条直线，让每一种类别数据的投影点尽可能的接近，而红色和蓝色数据中心之间的距离尽可能的大。

![](https://upload-images.jianshu.io/upload_images/16911112-8deef0bf9add0f08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195;  上图中提供了两种投影方式，从直观上可以看出，右图要比左图的投影效果好，因为右图的黑色数据和蓝色数据各个较为集中，且类别之间的距离明显。左图则在边界处数据混杂。以上就是LDA的主要思想了，在实际应用中，我们的数据是多个类别的，我们的原始数据一般也是超过二维的，投影后的也一般不是直线，而是一个低维的超平面。

## 2. 瑞利商（Rayleigh quotient）与广义瑞利商（genralized Rayleigh quotient） 
### 2.1 瑞利商
* 用函数R(A,x)表示瑞利商，则有：
$$R(A,x) = \frac{x^HAx}{x^Hx}
$$其中x为非零向量，而A为n×n的Hermitan矩阵。所谓的Hermitan矩阵就是满足共轭转置矩阵和自己相等的矩阵，即$A^H=A$。如果我们的矩阵A是实矩阵，则满足$A^T=A$的矩阵即为Hermitan矩阵。

* 瑞利商R(A,x)有一个非常重要的性质，即它的最大值等于矩阵A最大的特征值，而最小值等于矩阵A的最小的特征值，也就是满足：
$$\lambda_{min} \leq \frac{x^HAx}{x^Hx} \leq \lambda_{max}$$

* 当向量x是标准正交基时，即满足$x^Hx=1$时，瑞利商退化为：
$$R(A,x) = x^HAx$$

### 2.2 广义瑞利商
* 用函数R(A,B,x)表示广义瑞利商，则有：
$$R(A,x) = \frac{x^HAx}{x^HBx}
$$其中x为非零向量，而A,B为n×n的Hermitan矩阵。B为正定矩阵。

* 我们令$x=B^{−1/2}x′$，则分母转化为：
$$x^HBx = x'^H(B^{-1/2})^HBB^{-1/2}x' = x'^HB^{-1/2}BB^{-1/2}x' = x'^Hx'$$

* 而分子转化为：
$$x^HAx =  x'^HB^{-1/2}AB^{-1/2}x'$$

* 此时我们的R(A,B,x)转化为R(A,B,x′)：
$$R(A,B,x') = \frac{x'^HB^{-1/2}AB^{-1/2}x'}{x'^Hx'}$$

&#8195; 利用前面的瑞利商的性质，我们可以很快的知道，R(A,B,x′)的最大值为矩阵$B^{-1/2}AB^{-1/2}$的最大特征值，或者说矩阵$B^{−1}A$的最大特征值，而最小值为矩阵$B^{−1}A$的最小特征值。

## 3. 二类LDA原理
&#8195; 回到LDA的原理上，我们希望LDA投影后同一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。现在我们首先从比较简单的二类LDA入手，分析LDA的原理。

* 假设我们的数据集
$$D=\{(x_1,y_1), (x_2,y_2), ...,((x_m,y_m))\}
$$其中任意样本$x_i为n维向量，y_i$∈{0,1}。

* 我们定义$N_j(j=0,1)$为第j类样本的个数，$X_j(j=0,1)$为第j类样本的集合，而$μ_j(j=0,1)$为第j类样本的均值向量，定义$Σ_j(j=0,1)$为第j类样本的协方差矩阵（严格说是缺少分母部分的协方差矩阵）。

* $μ_j$的表达式为：
$$\mu_j = \frac{1}{N_j}\sum\limits_{x \in X_j}x\;\;(j=0,1)$$

* $Σ_j$的表达式为：
$$\Sigma_j = \sum\limits_{x \in X_j}(x-\mu_j)(x-\mu_j)^T\;\;(j=0,1)
$$由于是两类数据，因此我们只需要将数据投影到一条直线上即可。

* 假设我们的投影直线是向量w，则对任意一个样本$x_i$，它在直线w的投影为$w^Tx_i$，对于我们的两个类别的中心点$μ_0,μ_1$在直线w的投影为$w^Tμ_0和w^Tμ_1$。

* 由于LDA需要让不同类别的数据的类别中心之间的距离尽可能的大，也就是我们要最大化$||w^Tμ_0−w^Tμ_1||_{22}$。

* 同时我们希望同一种类别数据的投影点尽可能的接近，也就是要同类样本投影点的协方差$w^TΣ_0w和w^TΣ_1w$尽可能的小，即最小化$w^T\Sigma_0w+w^T\Sigma_1w$。

* 综上所述，我们的优化目标为：
$$\underbrace{\argmax}_w\quad J(w) = \frac{||w^T\mu_0-w^T\mu_1||_2^2}{w^T\Sigma_0w+w^T\Sigma_1w} = \frac{w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w}$$

* 我们一般定义类内散度矩阵$S_w$为：
$$S_w = \Sigma_0 + \Sigma_1 = \sum\limits_{x \in X_0}(x-\mu_0)(x-\mu_0)^T + \sum\limits_{x \in X_1}(x-\mu_1)(x-\mu_1)^T$$

* 同时定义类间散度矩阵$S_b$为：
$$S_b = (\mu_0-\mu_1)(\mu_0-\mu_1)^T$$

* 这样我们的优化目标重写为：
$$\underbrace{arg\;max}_w\;\;J(w) = \frac{w^TS_bw}{w^TS_ww}$$

* 利用我们第二节讲到的广义瑞利商的性质，我们知道我们的J(w′)最大值为矩阵$S^{−\frac{1}{2}}_wS_bS^{−\frac{1}{2}}_w$的最大特征值，而对应的w′为$S^{−\frac{1}{2}}_wS_bS^{−\frac{1}{2}}_w$的最大特征值对应的特征向量。

* 而$S_w^{-1}S_b$的特征值和$S^{−\frac{1}{2}}_wS_bS^{−\frac{1}{2}}_w$的特征值相同，$S_w^{-1}S_b$的特征向量w和$S^{−\frac{1}{2}}_wS_bS^{−\frac{1}{2}}_w$的特征向量w′满足$w = S^{−\frac{1}{2}}_ww'$的关系。

* 注意到对于二类的时候，$S_bw$的方向恒平行于$μ_0−μ_1$，不妨令$S_bw=\lambda(\mu_0-\mu_1)$，将其带入：$(S_w^{-1}S_b)w=\lambda w$，可以得到$w=S_w^{-1}(\mu_0-\mu_1)$， 也就是说我们只要求出原始二类样本的均值和方差就可以确定最佳的投影方向w了。

## 4. 多类LDA原理
有了二类LDA的基础，我们再来看看多类别LDA的原理。

* 假设我们的数据集：
$$D=\{(x_1,y_1), (x_2,y_2), ...,((x_m,y_m))\}
$$其中任意样本$x_i$为n维向量，且：
$$y_i \in \{C_1,C_2,...,C_k\}$$

* 我们定义$Nj(j=1,2...k)$为第j类样本的个数，$X_j(j=1,2...k)$为第j类样本的集合，而$μ_j(j=1,2...k)$为第j类样本的均值向量，定义$Σ_j(j=1,2...k)$为第j类样本的协方差矩阵。

* 由于我们是多类向低维投影，则此时投影到的低维空间就不是一条直线，而是一个超平面了。假设我们投影到的低维空间的维度为d，对应的基向量为$(w_1,w_2,...w_d)$，基向量组成的矩阵为W, 它是一个n×d的矩阵。

* 此时我们的优化目标应该可以变成为：
$$\frac{W^TS_bW}{W^TS_wW}
$$其中$S_b = \sum\limits_{j=1}^{k}N_j(\mu_j-\mu)(\mu_j-\mu)^T$，μ为所有样本均值向量。
$$S_w =  \sum\limits_{j=1}^{k}S_{wj} = \sum\limits_{j=1}^{k}\sum\limits_{x \in X_j}(x-\mu_j)(x-\mu_j)^T$$

&#8195; 但是有一个问题，就是$W^TS_bW$和$W^TS_wW$都是矩阵，不是标量，无法作为一个标量函数来优化！也就是说，我们无法直接用二类LDA的优化方法。一般来说，我们可以用其他的一些替代优化目标来实现。

* 常见的一个LDA多类优化目标函数定义为：
$$\underbrace{\argmax}_W\quad J(W) = \frac{\prod\limits_{diag}W^TS_bW}{\prod\limits_{diag}W^TS_wW}
$$其中$\prod\limits_{diag}A$为A的主对角线元素的乘积，W为n×d的矩阵。

* J(W)的优化过程可以转化为：
$$J(W) = \frac{\prod\limits_{i=1}^dw_i^TS_bw_i}{\prod\limits_{i=1}^dw_i^TS_ww_i} = \prod\limits_{i=1}^d\frac{w_i^TS_bw_i}{w_i^TS_ww_i}
$$上式最右端为广义瑞利商，最大值是矩阵$S^{−1}_wS_b$的最大特征值,最大的d个值的乘积就是矩阵$S^{−1}_wS_b$的最大的d个特征值的乘积，此时对应的矩阵W为这最大的d个特征值对应的特征向量张成的矩阵。

* 由于W是一个利用了样本的类别得到的投影矩阵，因此它的降维到的维度d最大值为k-1。为什么最大维度不是类别数k呢？因为$S_b$中每个$μ_j−μ$的秩为1，因此协方差矩阵相加后最大的秩为k(矩阵的秩小于等于各个相加矩阵的秩的和)，但是由于如果我们知道前k-1个$μ_j$后，最后一个$μ_k$可以由前k-1个$μ_j$线性表示，因此$S_b$的秩最大为k-1，即特征向量最多有k-1个。

## 5. LDA算法流程

* 输入：数据集$D={(x_1,y_1),(x_2,y_2),...,((x_m,y_m))}$，其中任意样本$xi$为n维向量，$y_i∈{C_1,C_2,...,C_k}$，降维到的维度d。
* 输出：降维后的样本集$D′$
* 流程如下：
    * 1.计算类内散度矩阵$S_w$；

    * 2.计算类间散度矩阵$S_b$；
    * 3.计算矩阵$S^{−1}_wS_b$；
    * 4.计算$S^{−1}_wS_b$的最大的d个特征值和对应的d个特征向量$(w_1,w_2,...w_d)$，得到投影矩阵W；
    * 5.对样本集中的每一个样本特征$x_i$，转化为新的样本$z_i=W^Tx_i$；
    * 6.得到输出样本集$D′={(z_1,y_1),(z_2,y_2),...,((z_m,y_m))}$。

&#8195;  以上就是使用LDA进行降维的算法流程。实际上LDA除了可以用于降维以外，还可以用于分类。一个常见的LDA分类基本思想是假设各个类别的样本数据符合高斯分布，这样利用LDA进行投影后，可以利用极大似然估计计算各个类别投影数据的均值和方差，进而得到该类别高斯分布的概率密度函数。当一个新的样本到来后，我们可以将它投影，然后将投影后的样本特征分别带入各个类别的高斯分布概率密度函数，计算它属于这个类别的概率，最大的概率对应的类别即为预测类别。

## 6. LDA和PCA
LDA用于降维，和PCA有很多相同，也有很多不同的地方，因此值得好好的比较一下两者的降维异同点。

### 相同点
* 两者均可以对数据进行降维。

* 两者在降维时均使用了矩阵特征分解的思想。
* 两者都假设数据符合高斯分布。

### 不同点
* LDA是有监督的降维方法，而PCA是无监督的降维方法

* LDA降维最多降到类别数k-1的维数，而PCA没有这个限制。
* LDA除了可以用于降维，还可以用于分类。
* LDA选择分类性能最好的投影方向，而PCA选择样本点投影具有最大方差的方向。

这点可以从下图形象的看出，在某些数据分布下LDA比PCA降维较优。

![](https://upload-images.jianshu.io/upload_images/16911112-ba4c830a6b73d35c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当然，某些某些数据分布下PCA比LDA降维较优，如下图所示：

![](https://upload-images.jianshu.io/upload_images/16911112-f286a23f783b2798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 7. 小结
&#8195;  LDA算法既可以用来降维，又可以用来分类，但是目前来说，主要还是用于降维。在我们进行图像识别图像识别相关的数据分析时，LDA是一个有力的工具。下面总结下LDA算法的优缺点。

### 优点
* 在降维过程中可以使用类别的先验知识经验，而像PCA这样的无监督学习则无法使用类别先验知识。

* LDA在样本分类信息依赖均值而不是方差的时候，比PCA之类的算法较优。

### 缺点
* LDA不适合对非高斯分布样本进行降维，PCA也有这个问题。

* LDA降维最多降到类别数k-1的维数，如果我们降维的维度大于k-1，则不能使用LDA。当然目前有一些LDA的进化版算法可以绕过这个问题。
* LDA在样本分类信息依赖方差而不是均值的时候，降维效果不好。
* LDA可能过度拟合数据。

---

# 二、主成成分分析(PCA)
&#8195; **主成分分析（Principal components analysis**，以下简称**PCA**）是最重要的降维方法之一。在数据压缩消除冗余和数据噪音消除等领域都有广泛的应用。

## 1. PCA的思想

&#8195; PCA顾名思义，就是找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。具体的，假如我们的数据集是n维的，共有m个数据$(x^{(1)},x^{(2)},...,x^{(m)})$。我们希望将这m个数据的维度从n维降到n'维，希望这m个n'维的数据集尽可能的代表原始数据集。我们知道数据从n维降到n'维肯定会有损失，但是我们希望损失尽可能的小。

&#8195; 我们先看看最简单的情况，也就是n=2，n'=1,也就是将数据从二维降维到一维。数据如下图。我们希望找到某一个维度方向，它可以代表这两个维度的数据。图中列了两个向量方向，$u_1和u_2$，那么哪个向量可以更好的代表原始数据集呢？从直观上也可以看出，$u_1比u_2$好。

![](https://upload-images.jianshu.io/upload_images/16911112-b5958c50f4fd78c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 为什么$u_1$比$u_2$好呢？可以有两种解释，第一种解释是样本点到这个直线的距离足够近，第二种解释是样本点在这个直线上的投影能尽可能的分开。

&#8195; 假如我们把n'从1维推广到任意维，则我们的希望降维的标准为：样本点到这个超平面的距离足够近,或者说样本点在这个超平面上的投影能尽可能的分开。基于上面的两种标准，我们可以得到PCA的两种等价推导。

## 2. PCA的推导
### 2.1 基于最小投影距离

我们首先看第一种解释的推导，即样本点到这个超平面的距离足够近。

* 假设m个n维数据$(x^{(1)},x^{(2)},...,x^{(m)})$都已经进行了中心化，即
$$\sum\limits_{i=1}^{m}x^{(i)}=0$$

* 经过投影变换后得到的新坐标系为${w_1,w_2,...,w_n}$，其中w是标准正交基，即$||w||_2=1, w_i^Tw_j=0$。

* 如果我们将数据从n维降到n'维，即丢弃新坐标系中的部分坐标，则新的坐标系为${w_1,w_2,...,w_{n^{′}}}$，样本点$x^{(i)}$在n'维坐标系中的投影为：
$$z^{(i)}=(z^{(i)}_1,z^{(i)}_2,...,z^{(i)}_{n^{′}})^T
$$其中，$z_j^{(i)} = w_j^Tx^{(i)}$在低维坐标系里第j维的坐标。

* 如果我们用$z^{(i)}$来恢复原始数据$x^{(i)}$，则得到的恢复数据：
$$\overline{x}^{(i)} = \sum\limits_{j=1}^{n'}z_j^{(i)}w_j = Wz^{(i)}$$其中，W为标准正交基组成的矩阵。

* 现在我们考虑整个样本集，我们希望所有的样本到这个超平面的距离足够近，即最小化下式：
$$\sum\limits_{i=1}^{m}||\overline{x}^{(i)} - x^{(i)}||_2^2$$

* 将这个式子进行整理，可以得到:
$$\sum\limits_{i=1}^{m}||\overline{x}^{(i)} - x^{(i)}||_2^2=\sum\limits_{i=1}^{m}|| Wz^{(i)} - x^{(i)}||_2^2 \tag{1}$$

$$ =\sum\limits_{i=1}^{m}(Wz^{(i)})^T(Wz^{(i)}) - 2\sum\limits_{i=1}^{m}(Wz^{(i)})^Tx^{(i)} + \sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}\tag{2}$$

$$ =\sum\limits_{i=1}^{m}z^{(i)T}z^{(i)} - 2\sum\limits_{i=1}^{m}z^{(i)T}W^Tx^{(i)} +\sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}\tag{3}$$

$$ =\sum\limits_{i=1}^{m}z^{(i)T}z^{(i)} - 2\sum\limits_{i=1}^{m}z^{(i)T}z^{(i)}+\sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}\tag{4}$$

$$ =-\sum\limits_{i=1}^{m}z^{(i)T}z^{(i)}+\sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}\tag{5}$$

$$ =-tr( W^T(\sum\limits_{i=1}^{m}x^{(i)}x^{(i)T})W) +\sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}\tag{6}$$

$$ =-tr( W^TXX^TW)  + \sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}\tag{7}$$

&#8195; 其中第(1)步用到了$\overline{x}^{(i)}=Wz^{(i)}$，第二步用到了平方和展开，第(3)步用到了矩阵转置公式$(AB)^T =B^TA^T和W^TW=I$，第(4)步用到了$z^{(i)}=W^Tx^{(i)}$，第(5)步合并同类项，第(6)步用到了$z^{(i)}=W^Tx^{(i)}$和矩阵的[迹](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%B9/8889744?fr=aladdin)，第(7)步将代数和表达为矩阵形式。

* 注意到$\sum\limits_{i=1}^{m}x^{(i)}x^{(i)T}$是数据集的协方差矩阵，W的每一个向量$w_j$是标准正交基。而$\sum\limits_{i=1}^{m} x^{(i)T}x^{(i)}$是一个常量。最小化上式等价于：
$$\underbrace{arg\;min}_{W}\;-tr( W^TXX^TW), \;\;s.t. W^TW=I$$

* 利用拉格朗日函数可以得到：
$$J(W) = -tr( W^TXX^TW + \lambda(W^TW-I))$$

* 对W求导有$-XX^TW+\lambda W=0$，整理下即为：
$$XX^TW=\lambda W$$

* 这样可以更清楚的看出，W为$XX^T$的n'个特征向量组成的矩阵，而λ为$XX^T$的若干特征值组成的矩阵，特征值在主对角线上，其余位置为0。当我们将数据集从n维降到n'维时，需要找到最大的n'个特征值对应的特征向量。这n'个特征向量组成的矩阵W即为我们需要的矩阵。对于原始数据集，我们只需要用$z^{(i)}=W^Tx^{(i)}$，就可以把原始数据集降维到最小投影距离的n'维数据集。

### 2.2 基于最大投影方差
* 假设m个n维数据$(x^{(1)},x^{(2)},...,x^{(m)})$都已经进行了中心化，即：
$$\sum\limits_{i=1}^{m}x^{(i)}=0$$

* 经过投影变换后得到的新坐标系为${w_1,w_2,...,w_n}$，其中w是标准正交基，即：
$$||w||_2=1,\quad w_i^Tw_j=0$$

* 如果我们将数据从n维降到n'维，即丢弃新坐标系中的部分坐标，则新的坐标系为$ \{w_1,w_2,...,w_{n^{′}}\}$，样本点$x^{(i)}$在n'维坐标系中的投影为：
$$z^{(i)} = (z_1^{(i)}, z_2^{(i)},...,z_{n'}^{(i)})^T
$$其中，$z^{(i)}_j=w^{T}_j x^{(i)}是x^{(i)}$在低维坐标系里第j维的坐标。

* 对于任意一个样本$x^{(i)}$，在新的坐标系中的投影为$W^Tx^{(i)}$，在新坐标系中的投影方差为${x^{(i)}}^{T}WW^Tx^{(i)}$，要使所有的样本的投影方差和最大，也就是最大化$\sum\limits_{i=1}^{m}W^Tx^{(i)}x^{(i)T}W$的迹，即：
$$\underbrace{arg\;max}_{W}\;tr( W^TXX^TW)\quad s.t. W^TW=I$$

* 利用拉格朗日函数可以得到：
$$J(W) = tr( W^TXX^TW + \lambda(W^TW-I))$$

* 对W求导有$XX^TW+\lambda W=0$，整理下即为：
$$XX^TW=(-\lambda)W$$

&#8195; 和上面一样可以看出，W为$XX^T$的n'个特征向量组成的矩阵，而−λ为$XX^T$的若干特征值组成的矩阵，特征值在主对角线上，其余位置为0。当我们将数据集从n维降到n'维时，需要找到最大的n'个特征值对应的特征向量。这n'个特征向量组成的矩阵W即为我们需要的矩阵。对于原始数据集，我们只需要用$z^{(i)}=W^T x^{(i)}$就，可以把原始数据集降维到最小投影距离的n'维数据集。

## 4. PCA算法流程

&#8195; 从上面两节我们可以看出，求样本$x^{(i)}$的n'维的主成分其实就是求样本集的协方差矩阵$XX^T$的前n'个特征值对应特征向量矩阵W，然后对于每个样本$x^{(i)}$，做如下变换$z(i)=W^T x^{(i)}$，即达到降维的PCA目的。

* 输入：n维样本集$D=(x^{(1)},x^{(2)},...,x^{(m)})$，要降维到的维数n'。
* 输出：降维后的样本集D'。
* 算法的流程为：
    * 1. 对所有的样本进行中心化：$x^{(i)} = x^{(i)} - \frac{1}{m}\sum\limits_{j=1}^{m} x^{(j)}$；
    
    * 2. 计算样本的协方差矩阵$XX^T$；
    * 3. 对矩阵$XX^T$进行特征值分解；
    * 4. 取出最大的n'个特征值对应的特征向量$(w_1,w_2,...,w_{n′})$，将所有的特征向量标准化后，组成特征向量矩阵W；
    * 5. 对样本集中的每一个样本$x^{(i)}$，转化为新的样本$z^{(i)}=W^T x^{(i)}$；
    * 6. 得到输出样本集$D′=(z^{(1)},z^{(2)},...,z^{(m)})$。
有时候，我们不指定降维后的n'的值，而是换种方式，指定一个降维到的主成分比重阈值t。这个阈值t在(0,1]之间。假如我们的n个特征值为$λ_1≥λ_2≥...≥λ_n$，则n'可以通过下式得到:
$$\frac{\sum\limits_{i=1}^{n'}\lambda_i}{\sum\limits_{i=1}^{n}\lambda_i} \geq t$$

## 5. PCA实例

&#8195; 假设我们的数据集有10个二维数据(2.5,2.4), (0.5,0.7),(2.2,2.9), (1.9,2.2), (3.1,3.0), (2.3, 2.7), (2, 1.6), (1, 1.1), (1.5, 1.6), (1.1, 0.9)，需要用PCA降到1维特征。

&#8195; 首先我们对样本中心化，这里样本的均值为(1.81, 1.91),所有的样本减去这个均值向量后，即中心化后的数据集为(0.69, 0.49), (-1.31, -1.21), (0.39, 0.99), (0.09, 0.29), (1.29, 1.09), (0.49, 0.79), (0.19, -0.31), (-0.81, -0.81), (-0.31, -0.31), (-0.71, -1.01)。

* 现在我们开始求样本的协方差矩阵，由于我们是二维的，则协方差矩阵为：
$$\mathbf{XX^T} = \left( \begin{array}{ccc} cov(x_1,x_1) & cov(x_1,x_2)\\   cov(x_2,x_1) & cov(x_2,x_2) \end{array} \right)$$

* 对于我们的数据，求出协方差矩阵为：
$$\mathbf{XX^T} = \left( \begin{array}{ccc} 0.616555556 & 0.615444444\\    0.615444444 & 0.716555556 \end{array} \right)$$

* 求出特征值为$(0.0490833989，1.28402771)$；

* 对应的特征向量分别为：
$$(0.735178656, 0.677873399)^T,\quad (-0.677873399, -0.735178656)^T$$

* 则我们的$W=(−0.677873399,−0.735178656)^T$；

* 我们对所有的数据集进行投影$z^{(i)}=W^Tx^{(i)}$，得到PCA降维后的10个一维数据集为：
(-0.827970186， 1.77758033， -0.992197494， -0.274210416， -1.67580142， -0.912949103， 0.0991094375， 1.14457216, 0.438046137， 1.22382056)

## 6. 核主成分分析KPCA介绍

&#8195; 在上面的PCA算法中，我们假设存在一个线性的超平面，可以让我们对数据进行投影。但是有些时候，数据不是线性的，不能直接进行PCA降维。这里就需要用到和支持向量机一样的核函数的思想，先把数据集从n维映射到线性可分的高维N>n,然后再从N维降维到一个低维度n', 这里的维度之间满足n'<n<N。

&#8195; 使用了核函数的主成分分析一般称之为核主成分分析(Kernelized PCA, 以下简称KPCA。假设高维空间的数据是由n维空间的数据通过映射ϕ产生。

* 则对于n维空间的特征分解：
$$\sum\limits_{i=1}^{m}x^{(i)}x^{(i)T}W=\lambda W$$

* 映射为：
$$\sum\limits_{i=1}^{m}\phi(x^{(i)})\phi(x^{(i)})^TW=\lambda W$$

&#8195; 通过在高维空间进行协方差矩阵的特征值分解，然后用和PCA一样的方法进行降维。一般来说，映射ϕ不用显式的计算，而是在需要计算的时候通过核函数完成。由于KPCA需要核函数的运算，因此它的计算量要比PCA大很多。

## 7. 总结
&#8195; 作为一个非监督学习的降维方法，它只需要特征值分解，就可以对数据进行压缩，去噪。因此在实际场景应用很广泛。为了克服PCA的一些缺点，出现了很多PCA的变种，比如第六节的为解决非线性降维的KPCA，还有解决内存限制的增量PCA方法Incremental PCA，以及解决稀疏数据降维的PCA方法Sparse PCA等。

### 优点
* 1. 仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　
* 2. 各主成分之间正交，可消除原始数据成分间的相互影响的因素。
* 3. 计算方法简单，主要运算是特征值分解，易于实现。

### 缺点
* 1. 主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。
* 2. 方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。

---

# 三、奇异值分解SVD

&#8195; **奇异值分解(Singular Value Decomposition**，以下简称**SVD**)是在机器学习领域广泛应用的算法，它不光可以用于降维算法中的特征分解，还可以用于推荐系统，以及自然语言处理等领域。是很多机器学习算法的基石。

## 1. 回顾特征值和特征向量

* 我们首先回顾下特征值和特征向量的定义如下：
$$Ax=\lambda x
$$其中A是一个n×n的实对称矩阵，x是一个n维向量，则我们说λ是矩阵A的一个特征值，而x是矩阵A的特征值λ所对应的特征向量。

* 如果我们求出了矩阵A的n个特征值$λ_1≤λ_2≤...≤λn$，以及这n个特征值所对应的特征向量$\lbrace w_1,w_2,...w_n \rbrace$，如果这n个特征向量线性无关，那么矩阵A就可以用下式的特征分解表示：
$$A=W\Sigma W^{-1}
$$其中W是这n个特征向量所张成的n×n维矩阵，而Σ为这n个特征值为主对角线的n×n维矩阵。

* 一般我们会把W的这n个特征向量标准化，即满足$||w_i||_2=1$， 或者说$w^T_iw_i=1$，此时W的n个特征向量为标准正交基，满足$W^TW=I$，即$W^T=W^{−1}$,，也就是说W为酉矩阵。

* 这样我们的特征分解表达式可以写成：
$$A=W\Sigma W^T$$

注意到要进行特征分解，矩阵A必须为方阵。

## 2. SVD的定义

* SVD也是对矩阵进行分解，但是和特征分解不同，SVD并不要求要分解的矩阵为方阵。假设我们的矩阵A是一个m×n的矩阵，那么我们定义矩阵A的SVD为：
$$A = U\Sigma V^T
$$其中U是一个m×m的矩阵，Σ是一个m×n的矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值，V是一个n×n的矩阵。U和V都是酉矩阵，即满足$U^TU=I, V^TV=I$。下图可以很形象的看出上面SVD的定义：

![](https://upload-images.jianshu.io/upload_images/16911112-e2de2484b8159da9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 如果我们将A的转置和A做矩阵乘法，那么会得到n×n的一个方阵$A^TA$。既然$A^TA$是方阵，那么我们就可以进行特征分解，得到的特征值和特征向量满足下式：
$$(A^TA)v_i = \lambda_i v_i$$

* 这样我们就可以得到矩阵$A^TA$的n个特征值和对应的n个特征向量v了。将$A^TA$的所有特征向量张成一个n×n的矩阵V，就是我们SVD公式里面的V矩阵了。一般我们将V中的每个特征向量叫做A的右奇异向量。

* 如果我们将A和A的转置做矩阵乘法，那么会得到m×m的一个方阵$AA^T$。既然$AA^T$是方阵，那么我们就可以进行特征分解，得到的特征值和特征向量满足下式：
$$(AA^T)u_i = \lambda_i u_i$$

* 这样我们就可以得到矩阵$AA^T$的m个特征值和对应的m个特征向量u了。将$AA^T$的所有特征向量张成一个m×m的矩阵U，就是我们SVD公式里面的U矩阵了。一般我们将U中的每个特征向量叫做A的左奇异向量。U和V我们都求出来了，现在就剩下奇异值矩阵Σ没有求出了。由于Σ除了对角线上是奇异值其他位置都是0，那我们只需要求出每个奇异值σ就可以了。

* 我们注意到：
$$A=U\Sigma V^T \Rightarrow AV=U\Sigma V^TV \Rightarrow AV=U\Sigma \Rightarrow  Av_i = \sigma_i u_i  \Rightarrow  \sigma_i =  Av_i / u_i
$$这样我们可以求出我们的每个奇异值，进而求出奇异值矩阵Σ。

* 上面还有一个问题没有讲，就是我们说$A^TA$的特征向量组成的就是我们SVD中的V矩阵，而$AA^T$的特征向量组成的就是我们SVD中的U矩阵，这有什么根据吗？这个其实很容易证明，我们以V矩阵的证明为例。
$$A=U\Sigma V^T \Rightarrow A^T=V\Sigma^T U^T \Rightarrow A^TA = V\Sigma^T U^TU\Sigma V^T = V\Sigma^2V^T$$

* 上式证明使用了：$U^TU=I, \Sigma^T\Sigma=\Sigma^2。$。可以看出$A^TA$的特征向量组成的的确就是我们SVD中的V矩阵。类似的方法可以得到$AA^T$的特征向量组成的就是我们SVD中的U矩阵。

* 进一步我们还可以看出我们的特征值矩阵等于奇异值矩阵的平方，也就是说特征值和奇异值满足如下关系：
$$\sigma_i = \sqrt{\lambda_i}$$

* 这样也就是说，我们可以不用$\sigma_i =  Av_i / u_i$来计算奇异值，也可以通过求出$A^TA$的特征值取平方根来求奇异值。

## 3. SVD计算举例
* 这里我们用一个简单的例子来说明矩阵是如何进行奇异值分解的。我们的矩阵A定义为：
$$\mathbf{A} = \left( \begin{array}{ccc} 0& 1\\  1& 1\\   1& 0 \end{array} \right)$$

* 我们首先求出$A^TA和AA^T$：
$$\mathbf{A^TA} = \left( \begin{array}{ccc} 0& 1 &1\\ 1&1& 0 \end{array} \right) \left( \begin{array}{ccc} 0& 1\\  1& 1\\   1& 0 \end{array} \right) = \left( \begin{array}{ccc} 2& 1 \\ 1& 2 \end{array} \right)$$

$$\mathbf{AA^T} =  \left( \begin{array}{ccc} 0& 1\\  1& 1\\   1& 0 \end{array} \right) \left( \begin{array}{ccc} 0& 1 &1\\ 1&1& 0 \end{array} \right) = \left( \begin{array}{ccc} 1& 1 & 0\\ 1& 2 & 1\\ 0& 1& 1 \end{array} \right)$$

* 进而求出$A^TA$的特征值和特征向量：
$$\lambda_1= 3; v_1 = \left( \begin{array}{ccc} 1/\sqrt{2} \\ 1/\sqrt{2} \end{array} \right); \lambda_2= 1; v_2 = \left( \begin{array}{ccc} -1/\sqrt{2} \\ 1/\sqrt{2} \end{array} \right)$$

* 接着求$AA^T$的特征值和特征向量：
$$
\lambda_1= 3; u_1 = \left( \begin{array}{ccc} 1/\sqrt{6} \\ 2/\sqrt{6} \\ 1/\sqrt{6} \end{array} \right); \lambda_2= 1; u_2 = \left( \begin{array}{ccc} 1/\sqrt{2} \\ 0 \\ -1/\sqrt{2} \end{array} \right);  \lambda_3= 0; u_3 = \left( \begin{array}{ccc} 1/\sqrt{3} \\ -1/\sqrt{3} \\ 1/\sqrt{3} \end{array} \right)
$$

* 利用$Av_i = \sigma_i u_i, i=1,2$求奇异值：
$$\left( \begin{array}{ccc} 0& 1\\  1& 1\\   1& 0 \end{array} \right) \left( \begin{array}{ccc} 1/\sqrt{2} \\ 1/\sqrt{2} \end{array} \right) = \sigma_1 \left( \begin{array}{ccc} 1/\sqrt{6} \\ 2/\sqrt{6} \\ 1/\sqrt{6} \end{array} \right) \Rightarrow  \sigma_1=\sqrt{3}$$

$$\left( \begin{array}{ccc} 0& 1\\  1& 1\\   1& 0 \end{array} \right) \left( \begin{array}{ccc} -1/\sqrt{2} \\ 1/\sqrt{2} \end{array} \right) = \sigma_2 \left( \begin{array}{ccc} 1/\sqrt{2} \\ 0 \\ -1/\sqrt{2} \end{array} \right) \Rightarrow  \sigma_2=1$$

* 当然，我们也可以用$\sigma_i = \sqrt{\lambda_i}$直接求出奇异值为$\sqrt{3}$和1。最终得到A的奇异值分解为：
$$
A=U\Sigma V^T = \left( \begin{array}{ccc} 1/\sqrt{6} & 1/\sqrt{2} & 1/\sqrt{3} \\ 2/\sqrt{6} & 0 & -1/\sqrt{3}\\ 1/\sqrt{6} & -1/\sqrt{2} & 1/\sqrt{3} \end{array} \right) \left( \begin{array}{ccc} \sqrt{3} & 0 \\  0 & 1\\ 0 & 0 \end{array} \right) \left( \begin{array}{ccc} 1/\sqrt{2}  & 1/\sqrt{2}  \\ -1/\sqrt{2}  & 1/\sqrt{2}  \end{array} \right)
$$


## 4. SVD的一些性质

&#8195; 前面我们对SVD的定义和计算做了详细的描述，似乎看不出我们费这么大的力气做SVD有什么好处。那么SVD有什么重要的性质值得我们注意呢？

&#8195; 对于奇异值,它跟我们特征分解中的特征值类似，在奇异值矩阵中也是按照从大到小排列，而且奇异值的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上的比例。也就是说，我们也可以用最大的k个的奇异值和对应的左右奇异向量来近似描述矩阵。也就是说：
$$A_{m \times n} = U_{m \times m}\Sigma_{m \times n} V^T_{n \times n} \approx U_{m \times k}\Sigma_{k \times k} V^T_{k \times n}$$

&#8195; 其中k要比n小很多，也就是一个大的矩阵A可以用三个小的矩阵Um×k,Σk×k,VTk×n来表示。如下图所示，现在我们的矩阵A只需要灰色的部分的三个小矩阵就可以近似描述了。

![](https://upload-images.jianshu.io/upload_images/16911112-768053fc6baef490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&#8195; 由于这个重要的性质，SVD可以用于PCA降维，来做数据压缩和去噪。也可以用于推荐算法，将用户和喜好对应的矩阵做特征分解，进而得到隐含的用户需求来做推荐。同时也可以用于NLP中的算法，比如潜在语义索引（LSI）。

## 5. SVD用于PCA
&#8195; 在前面我们讲到要用PCA降维，需要找到样本协方差矩阵$X^TX$的最大的d个特征向量，然后用这最大的d个特征向量张成的矩阵来做低维投影降维。可以看出，在这个过程中需要先求出协方差矩阵$X^TX$，当样本数多样本特征数也多的时候，这个计算量是很大的。

&#8195; 注意到我们的SVD也可以得到协方差矩阵$X^TX$最大的d个特征向量张成的矩阵，但是SVD有个好处，有一些SVD的实现算法可以不求先求出协方差矩阵$X^TX$，也能求出我们的右奇异矩阵V。也就是说，我们的PCA算法可以不用做特征分解，而是做SVD来完成。这个方法在样本量很大的时候很有效。实际上，scikit-learn的PCA算法的背后真正的实现就是用的SVD，而不是我们我们认为的暴力特征分解。

&#8195; 假设我们的样本是m×n的矩阵X，如果我们通过SVD找到了矩阵$XX^T$最大的d个特征向量张成的m×d维矩阵U，则我们如果进行如下处理：
$$X'_{d \times n} = U_{d \times m}^TX_{m \times n}$$

&#8195; 可以得到一个d×n的矩阵X‘，这个矩阵和我们原来的m×n维样本矩阵X相比，行数从m减到了d，可见对行数进行了压缩。也就是说，左奇异矩阵可以用于行数的压缩。相对的，右奇异矩阵可以用于列数即特征维度的压缩，也就是我们的PCA降维。　　　　

## 6. SVD小结

&#8195; SVD作为一个很基本的算法，在很多机器学习算法中都有它的身影，由于SVD可以实现并行化，因此更是大展身手。SVD的原理不难，只要有基本的线性代数知识就可以理解，实现也很简单。当然，SVD的缺点是分解出的矩阵解释性往往不强，有点黑盒子的味道，不过这不影响它的使用。
